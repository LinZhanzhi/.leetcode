# 160. Intersection of Two Linked Lists - Solution Explanation

## Problem Overview

Given two singly linked lists, find the node at which they intersect (i.e., share the same memory address). Return `nullptr` if there is no intersection.

## Solution: Two-Pointer Technique

### Algorithm Steps

1. **Edge Case Handling**

   - If either `headA` or `headB` is `nullptr`, return `nullptr`
   - This handles cases where one or both lists are empty

2. **Initialize Two Pointers**

   - `ptrA = headA` (starts at beginning of list A)
   - `ptrB = headB` (starts at beginning of list B)

3. **Traverse with Pointer Switching**

   - Move both pointers one step at a time
   - When a pointer reaches the end of its list, switch it to the head of the other list
   - Continue until both pointers meet or both reach `nullptr`

4. **Termination Condition**
   - Loop continues while `ptrA != ptrB`
   - When they meet, we've found the intersection
   - When both are `nullptr`, there's no intersection

### Code Implementation

```cpp
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    // Handle edge cases
    if (headA == nullptr || headB == nullptr) {
        return nullptr;
    }

    ListNode *ptrA = headA;
    ListNode *ptrB = headB;

    // Two-pointer technique
    while (ptrA != ptrB) {
        // Move ptrA to next node, or to headB if at end
        ptrA = (ptrA == nullptr) ? headB : ptrA->next;

        // Move ptrB to next node, or to headA if at end
        ptrB = (ptrB == nullptr) ? headA : ptrB->next;
    }

    // ptrA and ptrB are now either at the intersection node or both null
    return ptrA;
}
```

## Why This Works: Mathematical Proof

### Key Insight

Both pointers travel the same total distance, ensuring they meet at the intersection point.

### Distance Calculation

Let's define:

- `a` = length of list A before intersection
- `b` = length of list B before intersection
- `c` = length of common part (intersection)

**Pointer A's path:**

- First traversal: `a + c` (list A)
- Second traversal: `b` (list B)
- Total: `a + c + b`

**Pointer B's path:**

- First traversal: `b + c` (list B)
- Second traversal: `a` (list A)
- Total: `b + c + a`

Both travel the same distance: `a + b + c`

## Example Walkthrough

### Example 1: Lists Intersect

```
List A: [4,1,8,4,5]     (length = 5)
List B: [5,6,1,8,4,5]   (length = 6)
Intersection: node with value 8
```

**Pointer Traversal:**

- `ptrA`: 4 → 1 → 8 → 4 → 5 → 5 → 6 → 1 → **8** (intersection)
- `ptrB`: 5 → 6 → 1 → 8 → 4 → 5 → 4 → 1 → **8** (intersection)

Both pointers meet at the node with value 8.

### Example 2: No Intersection

```
List A: [2,6,4]    (length = 3)
List B: [1,5]       (length = 2)
```

**Pointer Traversal:**

- `ptrA`: 2 → 6 → 4 → 1 → 5 → **null**
- `ptrB`: 1 → 5 → 2 → 6 → 4 → **null**

Both pointers reach `nullptr` simultaneously, indicating no intersection.

## Complexity Analysis

### Time Complexity: O(m + n)

- Each pointer traverses at most `m + n` nodes
- Where `m` and `n` are the lengths of the two lists

### Space Complexity: O(1)

- Only uses two pointers regardless of input size
- No additional data structures needed

## Key Advantages

1. **No Length Calculation**: Doesn't need to calculate list lengths first
2. **Single Pass**: Each pointer traverses the lists at most twice
3. **Constant Space**: Uses only two pointers
4. **Elegant Solution**: Simple and easy to understand
5. **Handles All Cases**: Works for intersecting and non-intersecting lists

## Alternative Approaches

### 1. Hash Set Method

```cpp
// Store nodes from first list in hash set
// Check second list against hash set
// Time: O(m + n), Space: O(m)
```

### 2. Length Difference Method

```cpp
// Calculate lengths of both lists
// Move longer list pointer by difference
// Traverse both lists together
// Time: O(m + n), Space: O(1)
```

## Edge Cases Handled

1. **Empty Lists**: Returns `nullptr` immediately
2. **Single Node Lists**: Works correctly
3. **Lists of Different Lengths**: Pointer switching handles this
4. **No Intersection**: Both pointers reach `nullptr`
5. **Complete Overlap**: Lists are identical
6. **Partial Overlap**: Lists share some nodes

## Summary

The two-pointer technique is an elegant solution that:

- Finds intersection nodes efficiently
- Uses minimal space
- Handles all edge cases
- Works regardless of list lengths
- Maintains original list structure

This approach leverages the mathematical property that both pointers travel equal distances, ensuring they meet at the intersection point or both reach the end simultaneously.
