/*
 * @lc app=leetcode id=89 lang=cpp
 *
 * [89] Gray Code
 */

// @lc code=start
class Solution {
public:
  // Generates the sequence of Gray codes for a given number of bits n.
  // Gray code is a binary numeral system where two successive values differ in
  // only one bit. The i-th Gray code can be generated by: i ^ (i >> 1) The
  // formula i ^ (i >> 1) generates the i-th Gray code. Why does this ensure
  // adjacent codes differ by only one bit?
  //
  // Let's consider two consecutive integers: i and i+1.
  // Their Gray codes are: G(i) = i ^ (i >> 1), G(i+1) = (i+1) ^ ((i+1) >> 1)
  //
  // The binary representations of i and i+1 differ at the least significant bit
  // where the carry occurs. When you compute i ^ (i >> 1), each bit in the
  // result is the XOR of the corresponding bit in i and the bit to its left.
  // This means that only the bit where the carry happens (the rightmost 0 in i
  // becomes 1 in i+1) will cause a change in the Gray code. All higher bits
  // remain the same or flip in a way that only one bit changes between G(i) and
  // G(i+1).
  //
  // More formally, the Gray code sequence generated by i ^ (i >> 1) is a
  // reflected binary code, which is known to have the property that each
  // successive value differs from the previous by exactly one bit.
  vector<int> grayCode(int n) {
    vector<int> res;
    int size = 1 << n; // There are 2^n Gray codes for n bits.
    for (int i = 0; i < size; ++i) {
      // For each number from 0 to 2^n - 1, compute its Gray code and add to the
      // result. The formula i ^ (i >> 1) flips the appropriate bits to ensure
      // only one bit changes at a time.
      res.push_back(i ^ (i >> 1));
    }
    return res;
  }
};
// @lc code=end
