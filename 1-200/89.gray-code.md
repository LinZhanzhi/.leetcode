Certainly! Let's provide a detailed mathematical proof explaining why the formula

$$
G(i) = i \oplus \left(\frac{i}{2}\right) = i \oplus (i >> 1)
$$

generates an **n-bit Gray code sequence** where each successive code differs from the previous one in exactly one bit.

## Background: What is Gray Code?

- A Gray code is a sequence of $2^n$ binary numbers each having $n$ bits.
- The key property: **Each successive code differs from the previous code in exactly one bit**.
- Additionally, the first and last codes differ by one bit as well (making it cyclic).
- Gray codes are commonly used in error correction, digital encoders, and analog to digital conversion to minimize the error when transitioning between codes.

## The Formula

$$
G(i) = i \oplus (i >> 1)
$$

where $\oplus$ denotes bitwise XOR, and $i >> 1$ is $i$ shifted right by one bit (i.e., $i$ divided by 2, discarding remainder).

## Step 1: Understand the Formula

Given an integer $i$, writing $i$ in binary as:

$$
i = b_{n-1} b_{n-2} \dots b_1 b_0
$$

Where each $b_k \in \{0, 1\}$.

Then:

$$
i >> 1 = b_{n-1} b_{n-2} \dots b_1
$$

but shifted right by one bit, i.e.,

$$
i >> 1 = 0 b_{n-1} b_{n-2} \dots b_1
$$

(assuming zero fill on left for unsigned shifts).

The Gray code:

$$
G(i) = G_{n-1} G_{n-2} \dots G_1 G_0
$$

where each bit $G_k$ is:

$$
G_k = b_k \oplus b_{k+1}
$$

with the convention $b_n = 0$ (since shift right inserts zero).

So explicitly:

- $G_{n-1} = b_{n-1} \oplus 0 = b_{n-1}$
- $G_{k} = b_k \oplus b_{k+1}$ for $k = 0, \ldots, n-2$

## Step 2: Prove successive Gray codes differ by exactly one bit

Consider two consecutive integers $i$ and $i+1$. We want to prove:

$$
\mathrm{HammingDistance}(G(i), G(i+1)) = 1
$$

where Hamming distance counts the number of bits which differ.

### Analysis of the binary representation of $i$ and $i+1$:

- When going from $i$ to $i+1$, the binary numbers differ in bits at and to the right of the rightmost zero bit of $i$.
- For example, suppose:

$$
i = \dots b_m = 0, b_{m-1} = 1, b_{m-2} = x, \dots
$$

- When incrementing $i$, bit $b_m$ flips from 0 to 1, all bits $b_{m-1}, b_{m-2}, \dots$ flip from 1 to 0 (the trailing ones turn into zeros).
- So the bits that change from $i$ to $i+1$ form a "run" at the right side: bits from 0 up to some position $m$.

### What about the Gray codes?

- Let:

$$
G(i) = i \oplus (i >> 1)
$$
$$
G(i+1) = (i+1) \oplus ((i+1) >> 1)
$$

- Define:

$$
D = G(i) \oplus G(i+1)
$$

We want to prove that $D$ has exactly one bit set.

### Key insight:

$$
D = G(i) \oplus G(i+1) = \bigl(i \oplus (i >> 1)\bigr) \oplus \bigl((i+1) \oplus ((i+1) >>1)\bigr) 
$$

Using XOR associativity and commutativity,

$$
D = \bigl(i \oplus (i+1)\bigr) \oplus \bigl((i >>1) \oplus ((i+1) >>1)\bigr)
$$

Note:

- $i \oplus (i+1)$ produces a binary number with bits set in the positions where $i$ and $i+1$ differ.
- Because $i$ and $i+1$ differ only in the rightmost zero bit and trailing ones, we know:

$$
i \oplus (i+1) = 2^r - 1
$$

where $r$ is the position of the rightmost zero bit (counting from 0 at least significant bit).

For example, if incrementing flips bits 0 to 2:

$$
i \oplus (i+1) = 0000 \dots 0111_2 = 2^3 - 1 = 7
$$

Consider the shifted term:

$$
(i >> 1) \oplus ((i+1) >> 1) = \frac{i \oplus (i+1)}{2}
$$

because shifting right by 1 discards the least significant bit.

Therefore,

$$
D = (i \oplus (i+1)) \oplus \frac{i \oplus (i+1)}{2}
$$

But $i \oplus (i+1) = 2^r - 1$.

Dividing by 2:

$$
\frac{i \oplus (i+1)}{2} = 2^{r-1} - \frac{1}{2}
$$

Since working with integers, this removes the least significant set bit.

Actually, the exact expression can be simplified by recognizing $2^r - 1$ in binary is a string of $r$ ones: $111 \dots 1_r$.

Dividing by 2 shifts right by 1:

$$
(111 \dots 1_r)_2 >> 1 = (111 \dots 1_{r-1})_2
$$

So:

$$
D = (111 \dots 1_r)_2 \oplus (111 \dots 1_{r-1})_2 = (100 \dots 0)_2
$$

which is a binary number with only the $r^{th}$ bit set (counting bit 0 as LSB). This means **exactly one bit differs** between $G(i)$ and $G(i+1)$.

### Example:

For $r = 3$,

$$
i \oplus (i+1) = 111_2 = 7
$$

$$
\frac{i \oplus (i+1)}{2} = 011_2 = 3
$$

$$
D = 111_2 \oplus 011_2 = 100_2 = 4
$$

which has a single 1-bit at position 2 (bits count from 0).

## Step 3: The First and Last Gray codes differ in one bit

- Since the Gray codes are enumerated for $i = 0$ to $2^n - 1$,
- Last code is $G(2^n - 1)$,
- First code is $G(0) = 0$.

Due to the "reflected" nature of Gray code (a standard property), the first and last codes differ by one bit.

The **"reflected" nature of Gray code** refers to the specific method by which the Gray code sequence is constructed, ensuring that each consecutive value differs by only one bit and that the sequence is cyclic.

### Reflect-and-Prefix Construction

To generate an n-bit Gray code sequence:
1. **Start with the (n−1)-bit Gray code sequence.**
2. **Reflect** (reverse) this existing sequence.
3. **Prefix '0'** to each code in the original sequence.
4. **Prefix '1'** to each code in the reflected sequence.
5. **Concatenate** the original prefixed list with the reflected prefixed list.

**Example for 3 bits:**
- Start with the 2-bit Gray code: 00, 01, 11, 10
- Reflect it: 10, 11, 01, 00
- Prefix:
  - 0 + original: 000, 001, 011, 010
  - 1 + reflected: 110, 111, 101, 100
- Concatenate: 000, 001, 011, 010, 110, 111, 101, 100

### Why "Reflected"?

This construction is called "reflected" because the **sequence for n bits contains the (n−1)-bit sequence** followed by its mirror image (reflection) with the extra bit set to 1. The **reflected half guarantees** that only the prefixed bit changes between the "end" of one half and the "start" of the next, preserving the "one bit difference" property across the join as well[1][2][3][4].

### Cyclicity

Since the last value in the sequence (from the reflected half) and the first value (from the original half) differ only in that prefixed bit, the **first and last Gray codes always differ by exactly one bit**—making the code cyclic[1][2][4].

### Visual Illustration

For n = 2:

Original 1-bit codes: 0, 1  
Reflect: 1, 0  
Prefix: 00, 01 (original); 11, 10 (reflected)  
Concatenate: 00, 01, 11, 10

Notice that 10 (last), and 00 (first) differ only in the highest bit.

**In summary**: The reflected construction method gives Gray code its name, ensures its crucial property of one-bit difference for all adjacent pairs—including between the last and first elements—and explains why it is called a "reflected binary code"[1][2][3][4].

[1] https://www.geeksforgeeks.org/digital-logic/what-is-gray-code/
[2] https://en.wikipedia.org/wiki/Gray_code
[3] https://stackoverflow.com/questions/34555768/why-is-gray-code-called-reflected-code
[4] https://www.numberanalytics.com/blog/gray-code-guide-for-digital-designers
[5] https://link.springer.com/article/10.1007/BF01788686
[6] http://www.sciencedirect.com/science/article/pii/S0019995884800388/pdf?md5=27d0f3b0128c9b9e25c635dde06e4102&pid=1-s2.0-S0019995884800388-main.pdf

## Summary

- The formula $G(i) = i \oplus (i >> 1)$ maps consecutive integers $i$ to Gray codewords.
- The XOR structure ensures only one bit changes between $G(i)$ and $G(i+1)$.
- Proof exploits the pattern of bits changed when adding 1 to binary integers and how XOR with shifted versions isolates the one-bit change.
- The sequence generated for $i=0$ to $2^n -1$ forms a valid cyclic Gray code of length $2^n$, with adjacent pairs differing in exactly one bit.

## Intuitive Explanation

- Each Gray code bit is the XOR of two adjacent bits in the binary representation of $i$.
- This "differencing" hides a multi-bit increment into a single-bit flip step by step.
- This construction is known as the **reflected Gray code**.

If you want, I can also provide a visual illustration or walk through a worked example for $n=3$. Just ask!

[1] https://leetcode.com/problems/gray-code/description/
[2] https://leetcode.com