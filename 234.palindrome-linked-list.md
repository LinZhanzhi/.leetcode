# Palindrome Linked List — Algorithm Explanation

## Problem Recap
You are given a singly linked list head node, and you need to determine whether the linked list's values form a palindrome (reads the same forwards and backwards).

For example:
- `[1,2,2,1]` is a palindrome → return `true`
- `[1,2]` is not → return `false`

## Solution Overview
The solution uses **three main ideas**:
1. **Find the middle of the linked list using slow and fast pointers**
2. **Reverse the second half of the list in-place**
3. **Compare the first half and reversed second half node-by-node**

This approach runs in **O(n)** time and uses **O(1) space**, meeting the follow-up constraint.

---

## Detailed Explanation

### Step 1: Handle trivial cases
```cpp
if (!head || !head->next)
  return true;
```
- If the list is empty or has only one node, it’s trivially a palindrome.

### Step 2: Find the middle node
```cpp
ListNode *slow = head;
ListNode *fast = head;
while (fast && fast->next) {
  slow = slow->next;
  fast = fast->next->next;
}
```
- Use two pointers:
  - `fast` moves **2 steps** at a time.
  - `slow` moves **1 step** at a time.
- When `fast` reaches the end, `slow` is at the **middle** of the list.
- For **even-length lists**, `slow` will be at the start of the second half.

### Step 3: Reverse the second half in-place
```cpp
ListNode *prev = nullptr;
ListNode *curr = slow;
while (curr) {
  ListNode *nextTemp = curr->next;
  curr->next = prev;
  prev = curr;
  curr = nextTemp;
}
```
- Reverse the linked list starting from the middle (`slow`).
- This is a classic linked list reversal:
  - Temporarily store `curr->next`
  - Point `curr->next` to the previous node
  - Move `prev` and `curr` forward
- After this loop, `prev` points to the **head of the reversed second half**.

### Step 4: Compare the two halves
```cpp
ListNode *first = head;
ListNode *second = prev;
while (second) {
  if (first->val != second->val)
    return false;
  first = first->next;
  second = second->next;
}
```
- Initialize two pointers:
  - `first` starts at head (beginning of list)
  - `second` starts at head of reversed second half (`prev`)
- Compare values while `second` is not null (second half is shorter or equal in length).
- If any mismatch found, return `false`.
- If the loop finishes without mismatches, the list is a palindrome.

### Step 5: Return true if no mismatches found
```cpp
return true;
```

---

## Complexity Analysis
| Aspect          | Complexity     |
|-----------------|----------------|
| Time            | O(n) — one pass to find middle + one pass to reverse + one pass to compare |
| Space           | O(1) — reversed in place, no extra data structures used |

---

## Optional Improvement
- The problem does not require you to restore the original list, but sometimes interviewers ask you to restore the reversed half back to original order.

---

## Summary
1. Use **slow/fast pointers** to find the middle.
2. **Reverse the second half** of the linked list.
3. **Compare the first half and reversed second half** node values.
4. Return `true` if all matching; else `false`.

This is an efficient, classic way to check palindrome linked lists with minimal memory.

Let me know if you want me to walk through an example step-by-step!
