Here's a **very detailed proof** of the solution to the LeetCode problem **459. Repeated Substring Pattern**, using the following elegant algorithm:

```cpp
class Solution {
public:
  bool repeatedSubstringPattern(string s) {
    string copyDouble = s + s; // Duplicate the string
    string delChar = copyDouble.substr(1, copyDouble.size() - 2); // Remove the first and last character
    return delChar.find(s) != string::npos; // Check if original string appears inside
  }
};
```

## ðŸ” Problem Summary

Given a non-empty string $s$, determine whether it can be constructed by taking a **substring** and **repeating** it multiple times.

## ðŸ§  Key Insight

If a string $s$ can be written as $s = t + t + \dots + t$ (concatenated $k$ times, $k > 1$), then $s$ should appear at least once **inside $s + s$ (but without the edges)**.

## âœ… Final Algorithm Explained

```cpp
string copyDouble = s + s;
string delChar = copyDouble.substr(1, copyDouble.size() - 2);
return delChar.find(s) != string::npos;
```

Breakdown:

### Step 1: Duplicate the string

Letâ€™s define:
- Original string: $s$
- Let $n$ be the length of $s$

We define:  
$$
\text{copyDouble} = s + s
$$  
So if $s = \text{"abcabc"}$, then $\text{copyDouble} = \text{"abcabcabcabc"}$

### Step 2: Remove first and last characters

We remove the first and last character of $copyDouble$:
```cpp
string delChar = copyDouble.substr(1, copyDouble.size() - 2);
```
This creates a string of length $2n - 2$ that excludes the first and last characters of $s + s$.

- For $s = \text{"abab"}$:
  - $copyDouble = \text{"abababab"}$
  - Removing first and last: $\text{"bababa"}$

### Step 3: Search for $s$ in the middle substring

```cpp
return delChar.find(s) != string::npos;
```
This checks if $s$ is found inside $delChar$.

## âš–ï¸ Why This Works (Mathematical Proof)

Letâ€™s suppose:

- $s$ can be written as $t + t + \dots + t$ for some substring $t$ repeated $k$ times, $k > 1$.
- So, $s = t^k$, where $t$ is a proper substring of $s$.

Now consider $s + s$:

- It equals $t^k + t^k = t^{2k}$
- If we remove the first and last characters, the result must **still contain $s$** somewhere in the middle **if** $s$ is truly periodic.

Because:
- Imagine the string $s = t^k = t t t \dots t$
- Then $s + s = t^k + t^k$
- Omitting the first and last characters means we are dropping a part from the start of one $t$ and from the end of the last $t$
- Thus, some instance of $t^k = s$ must still remain inside the body

### Formal reasoning:

**Theorem:**  
Let $s$ be a non-empty string of length $n$. Then $s$ is composed of a repeated substring **iff** $s$ is found within $(s + s)[1:2n - 1]$ (i.e., the original string without first and last characters in $s + s$).

**Proof:**

- **If** $s = t^k$ for some $k > 1$ and $t$ of length $m < n$,  
  then $s + s = t^k + t^k = t^{2k}$ â‡’ clearly, $s$ appears inside after removing first and last characters.

- **Conversely**, suppose $s$ **appears inside** of $(s + s)[1:2n - 1]$.  
  This implies that thereâ€™s a shift where $s$ matches a proper rotation of itself. This is only possible if $s$ is composed of repeating patterns (i.e., it is periodic â‡’ a repeated substring).

- **If $s$ isnâ€™t periodic (e.g., â€œabaâ€):**
  Then $(s + s)[1:2n - 1]$ will not contain $s$, and `find(s)` will return `npos`.

## ðŸ§ª Examples Worked Out

### âœ”ï¸ Example 1: $s = \text{â€œababâ€}$

- $s + s = \text{â€œababababâ€}$
- Remove first and last: $\text{â€œbababaâ€}$
- â€œababâ€ is found â‡’ returns `true`

### âŒ Example 2: $s = \text{â€œabaâ€}$

- $s + s = \text{â€œabaabaâ€}$
- Remove first and last: $\text{â€œbaabâ€}$
- â€œabaâ€ not found â‡’ returns `false`

### âœ”ï¸ Example 3: $s = \text{â€œabcabcabcabcâ€}$

- $s + s = \text{â€œabcabcabcabcabcabcabcabcâ€}$
- Remove first and last: substring of length 22
- â€œabcabcabcabcâ€ appears in it â‡’ returns `true`

## ðŸ§  Time and Space Complexity

- **Time complexity:**  
  - $O(n)$ for string concatenation and search
- **Space complexity:**  
  - Extra string of size $2n - 2$ â‡’ $O(n)$

## âœ… Conclusion

This elegant trick exploits string concatenation and substring properties to detect repeated patterns without iterations:

- It cleverly removes the first and last characters of $s + s$
- Reliably finds string repetition using a **single substring search**
- Avoids manual looping over substrings or checking all divisors

It is a well-known string technique used for detecting **cyclic or periodic structures**.

âœ¨ **So the condition `s` is found in `(s + s)[1:-1]` if and only if `s` is composed of repeated substring(s) is both necessary and sufficient.**